import UIKit



//闭包的用法
/*
 闭包：闭包是可以在你的代码中被传递和引用的功能独立代码块。
      Swift中的闭包和C以及Objective-C中的blocks很像，还有其他语言中的匿名函数也类似。
 特性：闭包能够捕获和存储定义在其上下文中的任何常量和变量的引用，这也就是所谓的闭合和包裹那些常量和变量。
 闭包的形式：全局函数是个有名字，但不会捕获任何值的闭包
           内嵌函数是一个有名字能从其上层函数捕获值的闭包
           闭包表达式是一个轻量级语法所写的可以捕获其上下文中常量或变量值的没有名字的闭包
 闭包表达式：
 {(parameters)->(return type) in
   statements
 }
 闭包表达式语法能够使用常量形式参数、变量形式参数和输入输出形式参数，但不能提供默认值。
 可变形式参数也能使用，但需要在形式参数列表的最后面使用。
 元组也可被用来作为形式参数和返回类型
 
 闭包是引用类型：
 无论在什么时候赋值一个函数或者闭包给常量或者变量，实际上都是降常量和变量设置为函数和闭包的引用。
 
 逃逸闭包：
 当闭包作为一个实际参数传递给一个函数的时候，我们就说这个闭包逃逸了，因为它是在函数返回之后调用的。当声明一个接受闭包作为形式参数的函数时，，
 我们可以在形式参数前写 @escaping来明确闭包是允许逃逸的
 闭包可以逃逸的一种方法是被储存在定义于函数外的变量里，比如说，很多函数接收闭包实际参数来作为启动异步任务的回调。函数在启动任务后返回，
 但是闭包要直到任务完成---闭包需要逃逸，以便稍后调用
 **注意：逃逸闭包中，我们必须显示的引用self，非逃逸闭包，，需要隐式的引用self
 
 自动闭包：
 Swift语音中还有一种语法，其可以实现对简单闭包的自动生成，这种闭包被称为自动闭包。
 需要注意，自动闭包参数的使用有严格的条件，首先此闭包不能够有参数，其次在调用函数传参时，此闭包的实现只能由一句表达式组成，闭包的返回值即
 为此表达式的值，自动闭包参数由 @autoclosure来声明
 注意：自动闭包默认为非逃逸闭包，如果需要设置为逃逸闭包需要用 @escaping修饰
 */





/**
   闭包
   1.提前准备好的代码
   2.在需要的时候执行
   3.可以当作参数传递
 */


//1.最简单的闭包
//() -> ()没参数,没返回值的函数
//如果没有参数,没有返回值,可以省略,连in都可以省略
//option + click 参看类型(常量,变量,函数,闭包....)
let b1 = {
    print("hello")
}
//执行闭包
b1()

//2.带参数的闭包
//在闭包中,参数,返回值,实现代码写在{}中
//需要使用一个关键字'in' 分隔定义与实现
//{形参列表 -> 返回值类型 in  // 实现代码}
let b2 = { (x:Int) -> () in
    print(x)
}
//执行闭包
b2(1999999999)



//3.带参数/返回值的闭包
//在闭包中,参数,返回值,实现代码写在{}中
//需要使用一个关键字'in' 分隔定义与实现
//{形参列表 -> 返回值类型 in  // 实现代码}
let b3 = { (x:Int) -> Int in
   return x + 250
}
//执行闭包
print(b3(750))


demo()


func demo() {
    print(sum(x: 1, y: 2))
    //1.定义一个常量记录函数
    let f = sum
    //2.在需要的时候执行
    print(f(10, 30))
    
}

func sum(x: Int, y:Int) -> Int {
    return x + y
}
